(module cli G
  (defcap G () (enforce false "X"))

  (defschema cap
    name:string
    args:list
    signers:[string])

  (defschema signer
    signer:string
    signature:string)

  (defschema env
    gaslimit:integer
    gasprice:decimal
    msgdata:object)

  (defschema data
    sender:string
    ttl:integer
    network-id:string
    creation-time:time
    nonce:string
    host:string
    chain-id:integer
    chain-count:integer
    signers:[object{signer}]
    caps:[object{cap}]
    code:string
    env:object{env}
    )

  (defconst PACT_CHAIN_ID:integer -1
    "chain id of a pact -s server")

  (deftable state:{data})
  (defconst S "S")

  (defschema keydata
    key:string
    alias:string
    file:string)

  (deftable keystore:{keydata})

  (defun init ()
    (write
     state S
     { 'sender: "sender"
     , 'ttl: 150000
     , 'network-id: "mainnet01"
     , 'creation-time: (now)
     , 'nonce: "nonce"
     , 'host: "api.chainweb.com"
     , 'chain-id: 0
     , 'chain-count: 20
     , 'signers: []
     , 'caps: []
     , 'code: ""
     , 'env:
       { 'gaslimit: 5000
       , 'gasprice: 0.00000000001
       , 'msgdata: {}
       }
     })
    (conform-env)
    (rehash))

  (defun conform-env ()
    (with-read state S
      { 'env:= e }
      (env-data (at 'msgdata e))
      (env-gaslimit (at 'gaslimit e))
      (env-gasprice (at 'gasprice e))))

  (defun sstore (name:string)
    (write state name (cli-state)))

  (defun sload(name:string)
    (write state S (read state name))
    (conform-env)
    (rehash))

  (defun cli-state () (read state S))

  (defun mainnet ()
    (network-id "mainnet01")
    (host "api.chainweb.com")
    (rehash))

  (defun testnet ()
    (network-id "testnet04")
    (host "us1.testnet.chainweb.com")
    (rehash))

  (defun devnet ()
    (network-id "development")
    (host "us1.tn1.chainweb.com")
    (rehash))

  (defun update-state (u:object rh:bool)
    (update state S u)
    (conform-env)
    (if rh (rehash) "State updated"))

  (defun sender (s:string)
    "Set message sender/gaspayer account."
    (update-state { 'sender: s } true))

  (defun sender-key (key:string)
    "Set message sender/gaspayer account to KEY match in keystore."
    (sender (find-key key)))

  (defun gaslimit (i:integer)
    (update-env { 'gaslimit: i }))

  (defun gasprice (d:decimal)
    (update-env { 'gasprice: d }))

  (defun msgdata (o:object)
    (update-env { 'msgdata: o }))

  (defun update-env (e:object)
    (update-state
     { 'env:
       (+ e (at 'env (cli-state)))}
     true))

  (defun ttl (i:integer)
    (update-state { 'ttl: i } true))

  (defun network-id (s:string)
    (update-state { 'network-id: s } true))

  (defun creation-time (t:time)
    (update-state { 'creation-time: t } true))

  (defun nonce (s:string)
    (update-state { 'nonce: s } true))

  (defun host (h:string)
    (update-state { 'host: h } false))

  (defun chain-id (i:integer)
    (update-state { 'chain-id: i } true))

  (defun set-code (s:string)
    (update-state { 'code: s } true))

  (defun add-key:object{keydata} (key:string)
    (with-default-read keystore key
      { 'file: "", 'alias: "" }
      { 'file:= f, 'alias:= a }
      (let ((k { 'key: key, 'file: f, 'alias: a }))
        (write keystore key k)
        k)))

  (defun add-key-alias:object{keydata} (alias:string key:string)
    (with-default-read keystore key
      { 'file: "" }
      { 'file:= f }
      (let ((k { 'key: key, 'file: f, 'alias: alias }))
        (write keystore key k)
        k)))

  (defun add-keyfile1:object{keydata} (key:string file:string)
    (with-default-read keystore key
      { 'alias: "" }
      { 'alias:= a}
      (let ((k { 'key: key, 'file: file, 'alias: a }))
        (write keystore key k)
        (rehash)
        k)))

  (defun get-key:object{keydata} (key:string)
    (read keystore key))

  (defun add-cap1 (name:string args:list signers:[string])
    (let ((ss (map (add-signer) signers)))
      (update-state
       { 'caps:
         (+ [{ 'name: name
             , 'args: args
             , 'signers: ss }]
            (at 'caps (read state S)))}
       true)))

  (defun sign (signer:string signature:string)
    (let ((s (add-signer signer)))
      (update-state
       { 'signers:
         (map (sign1 s signature)
               (at 'signers (cli-state))) } true)
      (format "Added signature {}->{}" (map (elide) [signer signature]))))

  (defun elide:string (s:string)
    (if (< (length s) 12) s
      (+ (take 12 s) "...")))

  (defun sign1 (signer:string signature:string s:object{signer})
    (if (= signer (at 'signer s))
        (+ { 'signature: signature} s)
      s))


  (defun add-signer-unsafe (s:string sig:string)
    (let ((ss (at 'signers (read state S))))
      (if (contains s (map (at 'signer) ss)) "Already added"
        (update-state
         { 'signers: (+ [{'signer:s,'signature:sig}] ss) } true))))

  (defun add-signer (signer:string)
    "Matches SIGNER to keystore to add to signers list."
    (enforce (!= "" signer) "Empty signer")
    (let ((matched (find-key signer)))
      (add-signer-unsafe matched "")
      matched))

  (defun add-keyset-signers (aliased-only:bool k:keyset)
    " Adds all keys in keyset to signers unless ALIASED-ONLY, in which \
    \ case only adds aliased keys."
    (let* ((ks (add-keyset k))
           (ks1 (if aliased-only
                    (filter (compose (at 'alias) (!= "")) ks)
                  ks)))
      (map (compose (at 'key) (add-signer)) ks1)
      ks1))

  (defun clear-sigs ()
    (update-state
     { 'signers:
       (map (+ { 'signature: "" })
        (at 'signers (cli-state))) }
     false))

  (defun all-keys ()
    (select keystore (constantly true)))

  (defun find-key:string (k:string)
    "Searches keystore by key and alias for K, returning key string"
    (let ((matched (fold (match-key k) "" (all-keys))))
      (enforce (!= "" matched) (format "Key not found: {}" [k]))
      matched))

  (defun match-key (part:string r:string key:object{keydata})
    (if (or (= part (take (length part) (at 'key key)))
            (= part (take (length part) (at 'alias key))))
        (let ((x 0))
          (enforce (= "" r) "Multiple matches found")
          (at 'key key))
      r))


)
(create-table state)
(create-table keystore)
(init)
